---
layout: post
title: Block
date: 2025-12-24
tag: iOS
---

### Block

一、什么是 Block？（面试一句话版本）
<img src="/images/posts/Block/Block.png" > 
Block 是携带执行上下文的匿名函数对象，本质是一个 Objective-C 对象，用来封装一段代码及其捕获的变量。
<img src="/images/posts/Block/Block1.png" > 

关键词：
	•	匿名函数
	•	闭包（Closure）
	•	捕获上下文
	•	OC 对象（继承自 NSObject）

二、Block 的本质结构

Block 在底层是一个结构体
```
struct __block_impl {
    void *isa;
    int Flags;
    int Reserved;
    void (*FuncPtr)(void *);
};
```
📌 Block ≠ 函数指针
👉 Block = 函数指针 + 环境变量

三、Block 的三种类型
1️⃣ NSGlobalBlock（全局 Block）
```
void (^block)(void) = ^{
    NSLog(@"Hello");
};
```
特点：
	•	不捕获任何外部变量
	•	存在 全局区
	•	不需要 copy
	•	生命周期贯穿整个程序
2️⃣ NSStackBlock（栈 Block）
```
int a = 10;
void (^block)(void) = ^{
    NSLog(@"%d", a);
};
```
特点：
	•	捕获了局部变量
	•	默认在 栈上
	•	超出作用域就销毁
	•	⚠️ 不能直接返回使用

3️⃣ NSMallocBlock（堆 Block）
```
int a = 10;
void (^block)(void) = [^{
    NSLog(@"%d", a);
} copy];
```
特点：
	•	copy 到堆
	•	生命周期由引用计数管理
	•	ARC 下多数场景自动 copy

⭐ ARC 下的自动 copy 规则

```
以下情况会 自动 copy 到堆：
	•	Block 作为属性
	•	Block 作为方法返回值
	•	Block 赋值给 __strong 指针
	•	GCD 中使用的 Block
```

四、Block 对变量的捕获规则（重点）

<img src="/images/posts/Block/Block5.png" > 

1️⃣ 自动变量（局部变量）

```
int a = 10;
void (^block)(void) = ^{
    NSLog(@"%d", a);
};
```
	•	捕获的是 值
	•	修改外部 a ❌ 不允许

2️⃣ __block 修饰变量（必考）
```
__block int a = 10;
void (^block)(void) = ^{
    a = 20;
};
```
特点：
	•	捕获的是 引用
	•	底层会生成 __Block_byref_a 结构体
	•	可被修改
	•	ARC 下可能从栈迁移到堆
```	
__block 本质是把变量包装成一个结构体，通过指针访问。
```
<img src="/images/posts/Block/Block2.png" > 
<img src="/images/posts/Block/Block3.png" > 
<img src="/images/posts/Block/Block4.png" > 

3️⃣ 对象类型变量（强引用陷阱）

```
NSObject *obj = [[NSObject alloc] init];
void (^block)(void) = ^{
    NSLog(@"%@", obj);
};
```
	•	默认是 强引用
	•	Block → obj
	•	容易形成循环引用

五、Block 的循环引用

self.block = ^{
    [self doSomething];
};
```
self → block
block → self
```
❌ 永远无法释放

正确写法（weak-strong dance）
```
__weak typeof(self) weakSelf = self;
self.block = ^{
    __strong typeof(weakSelf) self = weakSelf;
    if (!self) return;
    [self doSomething];
};
```

	•	weak 防止循环
	•	strong 防止执行过程中对象被释放

六、Block 作为属性为什么用 copy？

<img src="/images/posts/Block/Block6.png" > 


@property (nonatomic, copy) void (^block)(void);

原因：
	1.	Stack Block 生命周期短
	2.	copy → Malloc Block
	3.	保证 Block 长期有效


Block 用 copy 是为了防止栈 Block 被销毁。
七、Block 与 GCD 的关系
```
dispatch_async(queue, ^{
    // block
});
```
	•	GCD 内部会 copy Block
	•	所以在 GCD 中使用 Block 是安全的
	•	但循环引用依然可能发生

八、Block 与代理（Delegate）对比
<img src="/images/posts/Block/Block7.png" > 


```
1️⃣ Block 本质是对象，封装了函数和上下文
2️⃣ 有 Global / Stack / Malloc 三种
3️⃣ 捕获变量时默认拷贝值，对象是强引用
4️⃣ __block 用于修改变量，本质是结构体引用
5️⃣ Block 属性必须用 copy
6️⃣ 使用 Block 最重要的是避免循环引用
```



<br>
转载请注明：[iTwinkle的博客](https://itwinkle.github.io/) » [Block](http://iWolf.com/2025/12/Block)  
   