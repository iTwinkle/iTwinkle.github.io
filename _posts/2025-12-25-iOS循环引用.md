---
layout: post
title: iOS循环引用
date: 2025-12-25
tag: iOS
---

### iOS循环引用
一、什么是循环引用（Retain Cycle）

两个或多个对象之间互相 strong 持有，导致引用计数永远不为 0，dealloc 永远不调用。
```
A strong → B
B strong → A
```
即使外部已经不再使用 A、B，它们也无法释放。

二、iOS 为什么容易出现循环引用
iOS 使用 ARC（自动引用计数），但 ARC 不会自动打破循环引用。

常见“高危点”：
三、最常见：Block 循环引用

❌ 错误写法（100% 循环引用）
@interface Player ()
@property (nonatomic, strong) void (^block)(void);
@end

```
self.block = ^{
    [self play];
};
```
关系图：
```
self ─strong→ block
block ─strong→ self
```

✅ 正确写法：weak-strong dance
```
__weak typeof(self) weakSelf = self;
self.block = ^{
    __strong typeof(weakSelf) self = weakSelf;
    [self play];
};
```
原理：
	•	block 持有 weakSelf
	•	weakSelf 不增加引用计数
	•	执行时再转成 strong，保证安全
⚠️ 面试加分点
为什么 block 默认会强引用 self？
答：
	•	block 会捕获其作用域内使用的对象
	•	ARC 下默认是 strong
	•	除非使用 __weak / __unsafe_unretained
四、NSTimer 循环引用
```
self.timer = [NSTimer scheduledTimerWithTimeInterval:1
                                              target:self
                                            selector:@selector(tick)
                                            userInfo:nil
                                             repeats:YES];
 ```
循环关系：
self ─strong→ timer
timer ─strong→ self
✅ 解决方案 1：invalidate（最推荐）
```
- (void)dealloc {
    [self.timer invalidate];
}
```

✅ 解决方案 2：Block + weak
```
__weak typeof(self) weakSelf = self;
self.timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {
    [weakSelf tick];
}];
```

五、Delegate 循环引用

❌ 错误 delegate 定义
```
@property (nonatomic, strong) id<XXXDelegate> delegate;
```

✅ 正确写法
```
@property (nonatomic, weak) id<XXXDelegate> delegate;
```

为什么？
	•	delegate 本质是“回调”
	•	不应该拥有生命周期
	•	UIKit 全部使用 weak delegate

六、GCD / 异步任务中的循环引用
❌ 错误

```
dispatch_async(queue, ^{
    [self doSomething];
});
```
如果：
	•	queue 是长期存活
	•	block 被强持有

就会造成 延迟释放甚至泄漏

✅ 正确
```
__weak typeof(self) weakSelf = self;
dispatch_async(queue, ^{
    [weakSelf doSomething];
});
```
七、CADisplayLink / 视频渲染（和你项目高度相关）
```
self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(render)];
[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
```
```
- (void)dealloc {
    [self.link invalidate];
}
```

八、单例 + Block = 隐形杀手
[PlayerManager shared].callback = ^{
    [self updateUI];
};

⚠️ 单例 几乎等于永生对象
→ 一旦强持有 self，ViewController 永远不释放
✅ 必须 weak

九、如何快速定位循环引用
```
- (void)dealloc {
    NSLog(@"%@ dealloc", self);
}
```

2️⃣ Instruments – Leaks / Allocations
	•	看 VC 是否退出后还在内存
	•	查看 Retain Cycle 图

3️⃣ Xcode Memory Graph
	•	Debug → Memory Graph
	•	直接看到引用链

```
iOS 循环引用本质是 对象之间相互强引用，ARC 无法自动打破。
最常见场景是 Block、NSTimer、Delegate、单例回调。
解决方案是 weak 引用、invalidate、打破持有链，并通过 Memory Graph / Instruments 定位。
```
<br>
转载请注明：[iTwinkle的博客](https://itwinkle.github.io/) » [iOS循环引用](http://iWolf.com/2025/12/iOS循环引用)  
   